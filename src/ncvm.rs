#![allow(warnings)]
pub mod register {
	pub const R0: REGISTER = 0;
	pub const R1: REGISTER = 1;
	pub const R2: REGISTER = 2;
	pub const R3: REGISTER = 3;
	pub const R4: REGISTER = 4;
	pub const R5: REGISTER = 5;
	pub const R6: REGISTER = 6;
	pub const R7: REGISTER = 7;
	pub const D0: REGISTER = 0;
	pub const D1: REGISTER = 1;
	pub const D2: REGISTER = 2;
	pub type REGISTER = ::std::os::raw::c_uchar;
}
use register::REGISTER;
pub mod opcode {
	pub const NOP: OPCODE = 0;
	pub const STOP: OPCODE = 1;
	pub const RET: OPCODE = 2;
	pub const IPUSH: OPCODE = 3;
	pub const IPOP: OPCODE = 4;
	pub const ISTLD: OPCODE = 5;
	pub const ISTST: OPCODE = 6;
	pub const LPUSH: OPCODE = 7;
	pub const LPOP: OPCODE = 8;
	pub const LSTLD: OPCODE = 9;
	pub const LSTST: OPCODE = 10;
	pub const FPUSH: OPCODE = 11;
	pub const FPOP: OPCODE = 12;
	pub const FSTLD: OPCODE = 13;
	pub const FSTST: OPCODE = 14;
	pub const DPUSH: OPCODE = 15;
	pub const DPOP: OPCODE = 16;
	pub const DSTLD: OPCODE = 17;
	pub const DSTST: OPCODE = 18;
	pub const ALLOC: OPCODE = 19;
	pub const FREE: OPCODE = 20;
	pub const HELD: OPCODE = 21;
	pub const HEST: OPCODE = 22;
	pub const IMOV: OPCODE = 23;
	pub const LMOV: OPCODE = 24;
	pub const FMOV: OPCODE = 25;
	pub const DMOV: OPCODE = 26;
	pub const ISR: OPCODE = 27;
	pub const ISMLD: OPCODE = 28;
	pub const ISMST: OPCODE = 29;
	pub const LSR: OPCODE = 30;
	pub const LSMLD: OPCODE = 31;
	pub const LSMST: OPCODE = 32;
	pub const FSR: OPCODE = 33;
	pub const FSMLD: OPCODE = 34;
	pub const FSMST: OPCODE = 35;
	pub const DSR: OPCODE = 36;
	pub const DSMLD: OPCODE = 37;
	pub const DSMST: OPCODE = 38;
	pub const IADD: OPCODE = 39;
	pub const ISUB: OPCODE = 40;
	pub const IMULT: OPCODE = 41;
	pub const IDIV: OPCODE = 42;
	pub const IMOD: OPCODE = 43;
	pub const IINC: OPCODE = 44;
	pub const IDEC: OPCODE = 45;
	pub const LADD: OPCODE = 46;
	pub const LSUB: OPCODE = 47;
	pub const LMULT: OPCODE = 48;
	pub const LDIV: OPCODE = 49;
	pub const LMOD: OPCODE = 50;
	pub const LINC: OPCODE = 51;
	pub const LDEC: OPCODE = 52;
	pub const FADD: OPCODE = 53;
	pub const FSUB: OPCODE = 54;
	pub const FMULT: OPCODE = 55;
	pub const FDIV: OPCODE = 56;
	pub const FINC: OPCODE = 57;
	pub const FDEC: OPCODE = 58;
	pub const DADD: OPCODE = 59;
	pub const DSUB: OPCODE = 60;
	pub const DMULT: OPCODE = 61;
	pub const DDIV: OPCODE = 62;
	pub const DINC: OPCODE = 63;
	pub const DDEC: OPCODE = 64;
	pub const FTOI: OPCODE = 65;
	pub const ITOF: OPCODE = 66;
	pub const DTOI: OPCODE = 67;
	pub const ITOD: OPCODE = 68;
	pub const FTOL: OPCODE = 69;
	pub const LTOF: OPCODE = 70;
	pub const DTOL: OPCODE = 71;
	pub const LTOD: OPCODE = 72;
	pub const FTOD: OPCODE = 73;
	pub const DTOF: OPCODE = 74;
	pub const JMP: OPCODE = 75;
	pub const IJEZ: OPCODE = 76;
	pub const IJNZ: OPCODE = 77;
	pub const IJEQ: OPCODE = 78;
	pub const IJNQ: OPCODE = 79;
	pub const IJML: OPCODE = 80;
	pub const IJEL: OPCODE = 81;
	pub const IJMG: OPCODE = 82;
	pub const IJEG: OPCODE = 83;
	pub const LJEZ: OPCODE = 84;
	pub const LJNZ: OPCODE = 85;
	pub const LJEQ: OPCODE = 86;
	pub const LJNQ: OPCODE = 87;
	pub const LJML: OPCODE = 88;
	pub const LJEL: OPCODE = 89;
	pub const LJMG: OPCODE = 90;
	pub const LJEG: OPCODE = 91;
	pub const FJEZ: OPCODE = 92;
	pub const FJNZ: OPCODE = 93;
	pub const FJEQ: OPCODE = 94;
	pub const FJNQ: OPCODE = 95;
	pub const FJML: OPCODE = 96;
	pub const FJEL: OPCODE = 97;
	pub const FJMG: OPCODE = 98;
	pub const FJEG: OPCODE = 99;
	pub const DJEZ: OPCODE = 100;
	pub const DJNZ: OPCODE = 101;
	pub const DJEQ: OPCODE = 102;
	pub const DJNQ: OPCODE = 103;
	pub const DJML: OPCODE = 104;
	pub const DJEL: OPCODE = 105;
	pub const DJMG: OPCODE = 106;
	pub const DJEG: OPCODE = 107;
	pub const L_CALL: OPCODE = 108;
	pub type OPCODE = ::std::os::raw::c_uchar;
}
use opcode::OPCODE;
/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Instruction {
    pub opcode: OPCODE,
    pub r1: ::std::os::raw::c_uchar,
    pub r2: ::std::os::raw::c_uchar,
    pub r3: Instruction_LongOrDouble,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Instruction_LongOrDouble {
    pub vali: ::std::os::raw::c_ulonglong,
    pub valf: f64,
}
#[test]
fn bindgen_test_layout_Instruction_LongOrDouble() {
    const UNINIT: ::std::mem::MaybeUninit<Instruction_LongOrDouble> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Instruction_LongOrDouble>(),
        8usize,
        concat!("Size of: ", stringify!(Instruction_LongOrDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<Instruction_LongOrDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(Instruction_LongOrDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vali) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction_LongOrDouble),
            "::",
            stringify!(vali)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction_LongOrDouble),
            "::",
            stringify!(valf)
        )
    );
}
#[test]
fn bindgen_test_layout_Instruction() {
    const UNINIT: ::std::mem::MaybeUninit<Instruction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Instruction>(),
        16usize,
        concat!("Size of: ", stringify!(Instruction))
    );
    assert_eq!(
        ::std::mem::align_of::<Instruction>(),
        8usize,
        concat!("Alignment of ", stringify!(Instruction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction),
            "::",
            stringify!(r1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r2) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction),
            "::",
            stringify!(r2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Instruction),
            "::",
            stringify!(r3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncvm {
    pub inst_p: *mut Instruction,
    pub inst_count: ::std::os::raw::c_ulong,
    pub static_mem_p: *mut ::std::os::raw::c_uchar,
    pub static_mem_size: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ncvm() {
    const UNINIT: ::std::mem::MaybeUninit<ncvm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ncvm>(),
        32usize,
        concat!("Size of: ", stringify!(ncvm))
    );
    assert_eq!(
        ::std::mem::align_of::<ncvm>(),
        8usize,
        concat!("Alignment of ", stringify!(ncvm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inst_p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvm),
            "::",
            stringify!(inst_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inst_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvm),
            "::",
            stringify!(inst_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_mem_p) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvm),
            "::",
            stringify!(static_mem_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).static_mem_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ncvm),
            "::",
            stringify!(static_mem_size)
        )
    );
}
extern "C" {
    pub fn ncvm_initArr(
        inst_p: *mut Instruction,
        inst_count: ::std::os::raw::c_ulong,
        static_mem_p: *mut ::std::os::raw::c_uchar,
        static_mem_size: ::std::os::raw::c_ulong,
    ) -> ncvm;
}
extern "C" {
    pub fn ncvm_initData(
        data_p: *const ::std::os::raw::c_char,
        data_size: ::std::os::raw::c_ulong,
    ) -> ncvm;
}
extern "C" {
    pub fn ncvm_free(vm: *mut ncvm);
}
extern "C" {
    #[doc = "@param vm VM"]
    pub fn ncvm_execute(vm: *mut ncvm) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ncvm_create_thread(
        vm: *mut ncvm,
        start_instr_p: *mut Instruction,
        ext_stack_p: *mut ::std::os::raw::c_uchar,
        ext_stack_s: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uchar;
}


